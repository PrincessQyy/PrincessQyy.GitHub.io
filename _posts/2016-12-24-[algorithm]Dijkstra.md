---
layout:     post
title:      "【算法设计】Dijkstra求解最短路径"
date:       2016-12-24 11:04:00
author:     "Yuki"
---

**实验要求**

使用贪心法求出给定图各点的最短路径，并计算算法的执行时间，分析算法的有效性。

**实验内容**

<img src="../../../../../img/blogs/Dijkstra/01.png">

已知一个有向网络G=(V,E)和源点V1，如上所示，求出从源点出发到图中其余顶点的最短路径。

**算法思想**

Dijkstra算法的基本思想是，设置顶点集合S并不断地作贪心选择来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。
初始时，S中仅含有源。设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。Dijkstra算法每次从V-S中取出具有最短特殊路长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。一旦S包含了所有V中顶点，dist就记录了从源到所有其它顶点之间的最短路径长度。

**算法步骤**

1.根据图构造邻接矩阵。

2.选取源点v0，定义集合s记录遍历过的点，定义集合prev记录当前结点的前一个点，定义集合dist记录当前节点到源点的最短路径。初始时，s只包含源点，即s＝{v0}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。

3.从U中选取一个距离v最小的顶点k，把k，加入s中（该选定的距离就是v到k的最短路径长度）。以k为新考虑的中间点，修改U中各顶点的距离；若从源点v0到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

4.重复步骤3直到所有顶点都包含在s中。

5.遍历数组prev，若终点u的前驱结点不是v0，则将前驱结点存放在列表中，直达找到v0，输出源点v0到终点u的最短路径所经过的结点并输出代价。

**完整代码如下**

    import time
    
    #找单源最短路径

    def Dijkstra(n,arcs,v0):
	    #记录加入集合s的点
	    s=[]
	    #记录当前节点的前一个点
	    prev=[]
	    #记录当前点到源点的最短路径
	    dist=[]
	
	    #初始化
	    for i in range(n):
	        s.append(0)
	        dist.append(arcs[v0][i])
	        
	        if(dist[i]==65535):
	            prev.append(-1)
	        else:
	            prev.append(v0)
	      
	    dist[v0]=0
	    s[v0]=1
	    #将未放入s集合的结点取dist最小值放入
	    for i in range(1,n):
	        mindist=65535
	        u=v0
	        #找未使用的点j的dist最小值
	        for j in range(0,n):
	            if(not s[j] and dist[j]<mindist):
	                u=j
	                mindist=dist[j]
	        s[u]=1
	        #更新dist
	        for k in range(1,n):
	            if(not s[k] and arcs[u][k]>0 and mindist+arcs[u][k]<dist[k]):
	                    dist[k]=mindist+arcs[u][k]
	                    prev[k]=u
	                    
	    return prev,dist

    #显示路径
    def showPath(n,prev,dist,v0):
	    for j in range(1,n):
	        temp=prev[j]
	        path=[]
	        while(temp!=v0):
	            path.append(temp)
	            temp=prev[temp]
	        print('源点1到结点%d的最短路径为：1-->'% (j+1),end=' ')
	        if (len(path)>0):
	            for i in range(len(path)-1,-1,-1):
	                print('%d-->' % (path[i]+1),end=' ')
	            print('%d\n代价为：%d' % (j+1,dist[j]))
	                
	        else:
	            print('%d\n代价为：%d' % (j+1,dist[j]))
                    
                
                
	#模块入口
	if __name__=='__main__':
	    start = time.clock()
	    #构造邻接矩阵
	    n=10
	    arcs=[[0,4,2,5,65535,65535,65535,65535,65535,65535],
	          [65535,0,65535,65535,7,5,65535,65535,65535,65535],
	          [65535,65535,0,65535,65535,9,65535,65535,65535,65535],
	          [65535,65535,65535,0,2,65535,7,65535,65535,65535],
	          [65535,65535,65535,65535,0,65535,65535,4,65535,65535],
	          [65535,65535,65535,65535,65535,0,65535,65535,65535,6],
	          [65535,65535,65535,65535,65535,65535,0,65535,3,65535],
	          [65535,65535,65535,65535,65535,65535,65535,0,65535,7],
	          [65535,65535,65535,65535,65535,65535,65535,65535,0,8],
	          [65535,65535,65535,65535,65535,65535,65535,65535,65535,0]]
	    #调用Dijkstra函数
	    prev,dist=Dijkstra(n,arcs,0)
	    #找路径
	    showPath(n,prev,dist,0)
	 
	    end = time.clock()
	    print ("运行时间为： %f s" % (end - start))

**运行结果**


<img src="../../../../../img/blogs/Dijkstra/02.png">
